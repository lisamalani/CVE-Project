'''
The file describes the steps in the process to visualize DICOM data 
and performs segmentation for the same.
'''

# %%
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import os
import cv2
from skimage import measure, morphology
from sklearn.cluster import KMeans, MeanShift, estimate_bandwidth

from load_read_dicom import load_scan, get_pixels_hu, resample
from mesh import make_mesh, plotly_3d, plt_3d, create_ply, read_ply
from segmentation import make_mask


# %%
### Path to dataset
dataset_path = 'D:/MSSD_CMU/SEM 03/CVE/Project/data/CBCTImages_HumanMaxilla(Max1-2)/'
# Directory to store output 
output_path = 'D:\MSSD_CMU\SEM 03\CVE\Project/output/'

dicom_files = os.listdir(dataset_path)
# Print out the first 5 file names to verify we're in the right folder.
print(f"Reading data from {dataset_path}")
print(f"Total of {len(dicom_files)} DICOM images.")

# %%
### Load, read, and display DICOM scans
id=0
patient = load_scan(dataset_path)
images = get_pixels_hu(patient)

### Save scans
save_path = os.path.join(output_path, f"fullimages_{id}.npy")
np.save(save_path, images)

### Create a histogram of all the voxel data in the study
images_to_process = np.load(save_path).astype(np.float64) 
plt.figure(figsize=(11, 7))
sns.set_style("whitegrid")
ax = sns.histplot(data=images_to_process.flatten(), bins=100, color='lightblue')
ax.set(xlabel="Hounsfield Units (HU)", ylabel="Frequency")
plt.xlim(-5000, 5000)
plt.xlabel("Hounsfield Units (HU)")
plt.ylabel("Frequency")
plt.title("")

# %%
### Displaying an Image Stack
id = 0
images_to_process = np.load(save_path)

def sample_stack(stack, rows=6, cols=6, start_with=10, show_every=12):
    fig,ax = plt.subplots(rows,cols,figsize=[30,30])
    for i in range(rows*cols):
        ind = start_with + i*show_every
        ax[int(i/rows),int(i % rows)].set_title(f'slice {ind}')
        ax[int(i/rows),int(i % rows)].imshow(stack[ind],cmap='gray')
        ax[int(i/rows),int(i % rows)].axis('off')
    plt.show()

sample_stack(images_to_process)

# %%
### Resampling

print(f"Slice Thickness: {patient[0].SliceThickness}")
print(f"Pixel Spacing (row, col): {patient[0].PixelSpacing[0]} , {patient[0].PixelSpacing[1]}")
# Because a CT slice is typically reconstructed at 512 x 512 voxels, each slice represents approximately 370 mm of data in length and width.

print(f"Shape before resampling: {images_to_process.shape}")
images_after_resample, spacing = resample(images_to_process, patient, [0.1,0.1,0.1])
print(f"Shape after resampling: {images_after_resample.shape}")

# %%
### 3D Plotting
# The marching cubes algorithm is used to generate a 3D mesh from the dataset. The plotly model will utilize a higher step_size with lower voxel threshold to avoid overwhelming the display.

verts, faces = make_mesh(images_after_resample, threshold=350, step_size=1)
# # plt_3d(verts, faces)
# plotly_3d(verts, faces)

# Create point cloud PLY
ply_file = 'full_stack.ply'
create_ply(verts, filename=ply_file)
read_ply(ply_file)

# %%
def remove_nan(img):
    h, w = img.shape
    for x in range(w):
        for y in range(h):
            if np.isnan(img[x][y]):
                img[x][y] = 1


def make_mask(image, display=False, meanShift = True):
    # Clean the image by to remove unwanted contour blobs
    k_e = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
    image = cv2.erode(image, k_e) 
    image = cv2.dilate(image, k_e)
    image = cv2.dilate(image, k_e)
    image = cv2.erode(image, k_e)

    # Get image size
    row_size= image.shape[0]
    col_size = image.shape[1]

    # Standardize the pixel values
    mean = np.mean(image)
    std = np.std(image)
    if std < 1e-5:
        std = 1
    image = image-mean
    image = image/std

    # Find the average pixel value
    # to renormalize washed out images
    middle = image[int(col_size/5):int(col_size/5*4),int(row_size/5):int(row_size/5*4)] 
    mean = np.mean(middle)  
    max = np.max(image)
    min = np.min(image)

    # To improve threshold finding, move the 
    # underflow and overflow on the pixel spectrum
    image[image==max]=mean
    image[image==min]=mean
    
    # Remove nan value
    remove_nan(image)

    image_data = np.reshape(middle,[np.prod(middle.shape),1])
    centers = None

    if not meanShift:
        # Using Kmeans to separate real tooth and holes
        kmeans = KMeans(n_clusters=2).fit(np.reshape(middle,[np.prod(middle.shape),1]))
        centers = sorted(kmeans.cluster_centers_.flatten())
    else:
        # Using mean shift clustering to separate real tooth and holes
        bandwidth1 = estimate_bandwidth(image_data, quantile=.04, n_jobs=-1)
        ms = MeanShift(bandwidth = bandwidth1 , n_jobs=-1, bin_seeding=True, cluster_all=True).fit(image_data)
        centers = sorted(ms.cluster_centers_.flatten())
    
        print(np.unique(ms.labels_))
        
    threshold = np.mean(centers)
    thresh_image = np.where(image<threshold,1.0,0.0)  # threshold the image

    # First erode away the finer elements, then dilate to include some of the pixels.  
    # We don't want to accidentally clip
    eroded = morphology.erosion(thresh_image,np.ones([3,3]))
    dilation = morphology.dilation(eroded,np.ones([8,8]))

    # Different labels are displayed in different colors
    labels = measure.label(dilation) 
    label_vals = np.unique(labels)
    regions = measure.regionprops(labels)
    good_labels = []
    for prop in regions:
        B = prop.bbox
        if B[2]-B[0]<row_size/10*9 and B[3]-B[1]<col_size/10*9 and B[0]>row_size/5 and B[2]<col_size/5*4:
            good_labels.append(prop.label)
    mask = np.ndarray([row_size,col_size],dtype=np.int8)
    mask[:] = 0


    #  Another large dilation in order to fill in and out the tooth mask
    for N in good_labels:
        mask = mask + np.where(labels==N,1,0)
    mask = morphology.dilation(mask,np.ones([10,10])) # one last dilation
    # mask = thinning(mask)
    
    if (display):
        fig, ax = plt.subplots(3, 2, figsize=[12, 12])
        ax[0, 0].set_title("Original")
        ax[0, 0].imshow(image, cmap='gray')
        ax[0, 0].axis('off')
        ax[0, 1].set_title("Threshold")
        ax[0, 1].imshow(thresh_image, cmap='gray')
        ax[0, 1].axis('off')
        ax[1, 0].set_title("After Erosion and Dilation")
        ax[1, 0].imshow(dilation, cmap='gray')
        ax[1, 0].axis('off')
        ax[1, 1].set_title("Color Labels")
        ax[1, 1].imshow(labels)
        ax[1, 1].axis('off')
        ax[2, 0].set_title("Final Mask")
        ax[2, 0].imshow(mask, cmap='gray')
        ax[2, 0].axis('off')
        ax[2, 1].set_title("Apply Mask on Original")
        ax[2, 1].imshow(mask*image, cmap='gray')
        ax[2, 1].axis('off')
        
        plt.show()
    return mask*image


# %%
### Segmentation

# One example for sanity check
image = images_after_resample[202]
make_mask(image, display=True)

# Apply Masks to All Slices
masked_teeth = []
for img in images_after_resample:
    masked_teeth.append(make_mask(img))

sample_stack(masked_teeth, show_every=10)
save_masked = os.path.join(output_path, f"maskedimages_{id}.npy", images)
np.save(output_path + "maskedimages_%d.npy" % (id), images)
# %%
