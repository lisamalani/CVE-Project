'''
Segmentation
    - Standardize the pixel value by subtracting the mean and dividing by the standard deviation
    - Identify the proper threshold by creating 2 KMeans clusters comparing centered on soft tissue/bone vs lung/air.
    - Using Erosion and Dilation which has the net effect of removing tiny features
    - Identify each distinct region as separate image labels
    - Using bounding boxes for each image label to identify
    - Create the masks
    - Apply mask onto the original image to erase voxels outside of the fields
'''

import matplotlib.pyplot as plt
import numpy as np
from skimage import measure, morphology
from sklearn.cluster import KMeans

def remove_nan(img):
    h, w = img.shape
    for x in range(w):
        for y in range(h):
            if np.isnan(img[x][y]):
                img[x][y] = 1

def make_mask(image, display=False):
    row_size= image.shape[0]
    col_size = image.shape[1]

    # Standardize the pixel values
    mean = np.mean(image)
    std = np.std(image)
    if std < 1e-5:
        std = 1
    
    image = image-mean
    image = image/std

    # Find the average pixel value
    # to renormalize washed out images
    middle = image[int(col_size/5):int(col_size/5*4),int(row_size/5):int(row_size/5*4)] 
    mean = np.mean(middle)  
    max = np.max(image)
    min = np.min(image)

    # To improve threshold finding, move the 
    # underflow and overflow on the pixel spectrum
    image[image==max]=mean
    image[image==min]=mean
    
    # Remove nan value
    remove_nan(image)

    # Using Kmeans to separate real tooth and holes
    kmeans = KMeans(n_clusters=2).fit(np.reshape(middle,[np.prod(middle.shape),1]))
    centers = sorted(kmeans.cluster_centers_.flatten())
    threshold = np.mean(centers)
    thresh_image = np.where(image<threshold,1.0,0.0)  # threshold the image

    # First erode away the finer elements, then dilate to include some of the pixels.  
    # We don't want to accidentally clip
    eroded = morphology.erosion(thresh_image,np.ones([3,3]))
    dilation = morphology.dilation(eroded,np.ones([8,8]))

    # Different labels are displayed in different colors
    labels = measure.label(dilation) 
    label_vals = np.unique(labels)
    regions = measure.regionprops(labels)
    good_labels = []
    for prop in regions:
        B = prop.bbox
        if B[2]-B[0]<row_size/10*9 and B[3]-B[1]<col_size/10*9 and B[0]>row_size/5 and B[2]<col_size/5*4:
            good_labels.append(prop.label)
    mask = np.ndarray([row_size,col_size],dtype=np.int8)
    mask[:] = 0


    #  After just the lungs are left, we do another large dilation
    #  in order to fill in and out
    for N in good_labels:
        mask = mask + np.where(labels==N,1,0)
    mask = morphology.dilation(mask,np.ones([10,10])) # one last dilation

    if (display):
        fig, ax = plt.subplots(3, 2, figsize=[12, 12])
        ax[0, 0].set_title("Original")
        ax[0, 0].imshow(image, cmap='gray')
        ax[0, 0].axis('off')
        ax[0, 1].set_title("Threshold")
        ax[0, 1].imshow(thresh_image, cmap='gray')
        ax[0, 1].axis('off')
        ax[1, 0].set_title("After Erosion and Dilation")
        ax[1, 0].imshow(dilation, cmap='gray')
        ax[1, 0].axis('off')
        ax[1, 1].set_title("Color Labels")
        ax[1, 1].imshow(labels)
        ax[1, 1].axis('off')
        ax[2, 0].set_title("Final Mask")
        ax[2, 0].imshow(mask, cmap='gray')
        ax[2, 0].axis('off')
        ax[2, 1].set_title("Apply Mask on Original")
        ax[2, 1].imshow(mask*image, cmap='gray')
        ax[2, 1].axis('off')
        
        plt.show()
    return mask*image